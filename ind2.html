<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    


(window.webpackJsonp = window.webpackJsonp || []).push([[95], {
    5122: function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return o
        }
        ));
        var r = n(1553);
        class o extends r.cb {
            constructor(e) {
                super(e),
                this.dracoLoader = null,
                this.ktx2Loader = null,
                this.meshoptDecoder = null,
                this.pluginCallbacks = [],
                this.register((function(e) {
                    return new f(e)
                }
                )),
                this.register((function(e) {
                    return new E(e)
                }
                )),
                this.register((function(e) {
                    return new M(e)
                }
                )),
                this.register((function(e) {
                    return new x(e)
                }
                )),
                this.register((function(e) {
                    return new R(e)
                }
                )),
                this.register((function(e) {
                    return new A(e)
                }
                )),
                this.register((function(e) {
                    return new v(e)
                }
                )),
                this.register((function(e) {
                    return new m(e)
                }
                )),
                this.register((function(e) {
                    return new _(e)
                }
                )),
                this.register((function(e) {
                    return new T(e)
                }
                )),
                this.register((function(e) {
                    return new h(e)
                }
                )),
                this.register((function(e) {
                    return new S(e)
                }
                )),
                this.register((function(e) {
                    return new y(e)
                }
                ))
            }
            load(e, t, n, o) {
                const c = this;
                let l;
                l = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : r.db.extractUrlBase(e),
                this.manager.itemStart(e);
                const h = function(t) {
                    o ? o(t) : console.error(t),
                    c.manager.itemError(e),
                    c.manager.itemEnd(e)
                }
                  , d = new r.F(this.manager);
                d.setPath(this.path),
                d.setResponseType("arraybuffer"),
                d.setRequestHeader(this.requestHeader),
                d.setWithCredentials(this.withCredentials),
                d.load(e, (function(data) {
                    try {
                        c.parse(data, l, (function(n) {
                            t(n),
                            c.manager.itemEnd(e)
                        }
                        ), h)
                    } catch (e) {
                        h(e)
                    }
                }
                ), n, h)
            }
            setDRACOLoader(e) {
                return this.dracoLoader = e,
                this
            }
            setDDSLoader() {
                throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
            }
            setKTX2Loader(e) {
                return this.ktx2Loader = e,
                this
            }
            setMeshoptDecoder(e) {
                return this.meshoptDecoder = e,
                this
            }
            register(e) {
                return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e),
                this
            }
            unregister(e) {
                return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
                this
            }
            parse(data, path, e, t) {
                let n;
                const o = {}
                  , c = {};
                if ("string" == typeof data)
                    n = JSON.parse(data);
                else if (data instanceof ArrayBuffer) {
                    if (r.db.decodeText(new Uint8Array(data,0,4)) === w) {
                        try {
                            o[l.KHR_BINARY_GLTF] = new N(data)
                        } catch (e) {
                            return void (t && t(e))
                        }
                        n = JSON.parse(o[l.KHR_BINARY_GLTF].content)
                    } else
                        n = JSON.parse(r.db.decodeText(new Uint8Array(data)))
                } else
                    n = data;
                if (void 0 === n.asset || n.asset.version[0] < 2)
                    return void (t && t(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
                const h = new re(n,{
                    path: path || this.resourcePath || "",
                    crossOrigin: this.crossOrigin,
                    requestHeader: this.requestHeader,
                    manager: this.manager,
                    ktx2Loader: this.ktx2Loader,
                    meshoptDecoder: this.meshoptDecoder
                });
                h.fileLoader.setRequestHeader(this.requestHeader);
                for (let i = 0; i < this.pluginCallbacks.length; i++) {
                    const e = this.pluginCallbacks[i](h);
                    c[e.name] = e,
                    o[e.name] = !0
                }
                if (n.extensionsUsed)
                    for (let i = 0; i < n.extensionsUsed.length; ++i) {
                        const e = n.extensionsUsed[i]
                          , t = n.extensionsRequired || [];
                        switch (e) {
                        case l.KHR_MATERIALS_UNLIT:
                            o[e] = new d;
                            break;
                        case l.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                            o[e] = new H;
                            break;
                        case l.KHR_DRACO_MESH_COMPRESSION:
                            o[e] = new P(n,this.dracoLoader);
                            break;
                        case l.KHR_TEXTURE_TRANSFORM:
                            o[e] = new O;
                            break;
                        case l.KHR_MESH_QUANTIZATION:
                            o[e] = new F;
                            break;
                        default:
                            t.indexOf(e) >= 0 && void 0 === c[e] && console.warn('THREE.GLTFLoader: Unknown extension "' + e + '".')
                        }
                    }
                h.setExtensions(o),
                h.setPlugins(c),
                h.parse(e, t)
            }
            parseAsync(data, path) {
                const e = this;
                return new Promise((function(t, n) {
                    e.parse(data, path, t, n)
                }
                ))
            }
        }
        function c() {
            let e = {};
            return {
                get: function(t) {
                    return e[t]
                },
                add: function(t, object) {
                    e[t] = object
                },
                remove: function(t) {
                    delete e[t]
                },
                removeAll: function() {
                    e = {}
                }
            }
        }
        const l = {
            KHR_BINARY_GLTF: "KHR_binary_glTF",
            KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
            KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
            KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
            KHR_MATERIALS_IOR: "KHR_materials_ior",
            KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
            KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
            KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
            KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
            KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
            KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
            KHR_MATERIALS_VOLUME: "KHR_materials_volume",
            KHR_TEXTURE_BASISU: "KHR_texture_basisu",
            KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
            KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
            KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
            EXT_TEXTURE_WEBP: "EXT_texture_webp",
            EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
            EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
        };
        class h {
            constructor(e) {
                this.parser = e,
                this.name = l.KHR_LIGHTS_PUNCTUAL,
                this.cache = {
                    refs: {},
                    uses: {},3lrl;
                }
            }
            _markDefs() {
                const e = this.parser
                  , t = this.parser.json.nodes || [];
                for (let n = 0, r = t.length; n < r; n++) {
                    const r = t[n];
                    r.extensions && r.extensions[this.name] && void 0 !== r.extensions[this.name].light && e._addNodeRef(this.cache, r.extensions[this.name].light)
                }
                <this9></r>
            }
            _loadLight(e) {
                const t = this.parser
                  , n = "light:" + e;
                let o = t.cache.get(n);
                if (o)
                    return o;
                const c = t.json
                  , l = ((c.extensions && c.extensions[this.name] || {}).lights || [])[e];
                let h;
                const d = new r.q(16777215);
                void 0 !== l.color && d.fromArray(l.color);
                const m = void 0 !== l.range ? l.range : 0;
                switch (l.type) {
                case "directional":
                    h = new r.x(d),
                    h.target.position.set(0, 0, -1),
                    h.add(h.target);
                    break;
                case "point":
                    h = new r.Eb(d),
                    h.distance = m;
                    break;
                case "spot":
                    h = new r.Ub(d),
                    h.distance = m,
                    l.spot = l.spot || {},
                    l.spot.innerConeAngle = void 0 !== l.spot.innerConeAngle ? l.spot.innerConeAngle : 0,
                    l.spot.outerConeAngle = void 0 !== l.spot.outerConeAngle ? l.spot.outerConeAngle : Math.PI / 4,
                    h.angle = l.spot.outerConeAngle,
                    h.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle,
                    h.target.position.set(0, 0, -1),
                    h.add(h.target);
                    break;
                default:
                    throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type)
                }
                return h.position.set(0, 0, 0),
                h.decay = 2,
                void 0 !== l.intensity && (h.intensity = l.intensity),
                h.name = t.createUniqueName(l.name || "light_" + e),
                o = Promise.resolve(h),
                t.cache.add(n, o),
                o
            }
            createNodeAttachment(e) {
                const t = this
                  , n = this.parser
                  , r = n.json.nodes[e]
                  , o = (r.extensions && r.extensions[this.name] || {}).light;
                return void 0 === o ? null : this._loadLight(o).then((function(e) {
                    return n._getNodeRef(t.cache, o, e)
                }
                ))
            }
        }
        class d {
            constructor() {
                this.name = l.KHR_MATERIALS_UNLIT
            }
            getMaterialType() {
                return r.lb
            }
            extendParams(e, t, n) {
                const o = [];
                e.color = new r.q(1,1,1),
                e.opacity = 1;
                const c = t.pbrMetallicRoughness;
                if (c) {
                    if (Array.isArray(c.baseColorFactor)) {
                        const t = c.baseColorFactor;
                        e.color.fromArray(t),
                        e.opacity = t[3]
                    }
                    void 0 !== c.baseColorTexture && o.push(n.assignTexture(e, "map", c.baseColorTexture, r.mc))
                }
                return Promise.all(o)
            }
        }
        class m {
            constructor(e) {
                this.parser = e,
                this.name = l.KHR_MATERIALS_EMISSIVE_STRENGTH
            }
            extendMaterialParams(e, t) {
                const n = this.parser.json.materials[e];
                if (!n.extensions || !n.extensions[this.name])
                    return Promise.resolve();
                const r = n.extensions[this.name].emissiveStrength;
                return void 0 !== r && (t.emissiveIntensity = r),
                Promise.resolve()
            }
        }
        class f {
            constructor(e) {
                this.parser = e,
                this.name = l.KHR_MATERIALS_CLEARCOAT
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? r.pb : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser
                  , o = n.json.materials[e];
                if (!o.extensions || !o.extensions[this.name])
                    return Promise.resolve();
                const c = []
                  , l = o.extensions[this.name];
                if (void 0 !== l.clearcoatFactor && (t.clearcoat = l.clearcoatFactor),
                void 0 !== l.clearcoatTexture && c.push(n.assignTexture(t, "clearcoatMap", l.clearcoatTexture)),
                void 0 !== l.clearcoatRoughnessFactor && (t.clearcoatRoughness = l.clearcoatRoughnessFactor),
                void 0 !== l.clearcoatRoughnessTexture && c.push(n.assignTexture(t, "clearcoatRoughnessMap", l.clearcoatRoughnessTexture)),
                void 0 !== l.clearcoatNormalTexture && (c.push(n.assignTexture(t, "clearcoatNormalMap", l.clearcoatNormalTexture)),
                void 0 !== l.clearcoatNormalTexture.scale)) {
                    const e = l.clearcoatNormalTexture.scale;
                    t.clearcoatNormalScale = new r.ec(e,e)
                }
                return Promise.all(c)
            }
        }
        class T {
            constructor(e) {
                this.parser = e,
                this.name = l.KHR_MATERIALS_IRIDESCENCE
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? r.pb : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser
                  , r = n.json.materials[e];
                if (!r.extensions || !r.extensions[this.name])
                    return Promise.resolve();
                const o = []
                  , c = r.extensions[this.name];
                return void 0 !== c.iridescenceFactor && (t.iridescence = c.iridescenceFactor),
                void 0 !== c.iridescenceTexture && o.push(n.assignTexture(t, "iridescenceMap", c.iridescenceTexture)),
                void 0 !== c.iridescenceIor && (t.iridescenceIOR = c.iridescenceIor),
                void 0 === t.iridescenceThicknessRange && (t.iridescenceThicknessRange = [100, 400]),
                void 0 !== c.iridescenceThicknessMinimum && (t.iridescenceThicknessRange[0] = c.iridescenceThicknessMinimum),
                void 0 !== c.iridescenceThicknessMaximum && (t.iridescenceThicknessRange[1] = c.iridescenceThicknessMaximum),
                void 0 !== c.iridescenceThicknessTexture && o.push(n.assignTexture(t, "iridescenceThicknessMap", c.iridescenceThicknessTexture)),
                Promise.all(o)
            }
        }
        class x {
            constructor(e) {
                this.parser = e,
                this.name = l.KHR_MATERIALS_SHEEN
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? r.pb : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser
                  , o = n.json.materials[e];
                if (!o.extensions || !o.extensions[this.name])
                    return Promise.resolve();
                const c = [];
                t.sheenColor = new r.q(0,0,0),
                t.sheenRoughness = 0,
                t.sheen = 1;
                const l = o.extensions[this.name];
                return void 0 !== l.sheenColorFactor && t.sheenColor.fromArray(l.sheenColorFactor),
                void 0 !== l.sheenRoughnessFactor && (t.sheenRoughness = l.sheenRoughnessFactor),
                void 0 !== l.sheenColorTexture && c.push(n.assignTexture(t, "sheenColorMap", l.sheenColorTexture, r.mc)),
                void 0 !== l.sheenRoughnessTexture && c.push(n.assignTexture(t, "sheenRoughnessMap", l.sheenRoughnessTexture)),
                Promise.all(c)
            }
        }
        class R {
            constructor(e) {
                this.parser = e,
                this.name = l.KHR_MATERIALS_TRANSMISSION
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? r.pb : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser
                  , r = n.json.materials[e];
                if (!r.extensions || !r.extensions[this.name])
                    return Promise.resolve();
                const o = []
                  , c = r.extensions[this.name];
                return void 0 !== c.transmissionFactor && (t.transmission = c.transmissionFactor),
                void 0 !== c.transmissionTexture && o.push(n.assignTexture(t, "transmissionMap", c.transmissionTexture)),
                Promise.all(o)
            }
        }
        class A {
            constructor(e) {
                this.parser = e,
                this.name = l.KHR_MATERIALS_VOLUME
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? r.pb : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser
                  , o = n.json.materials[e];
                if (!o.extensions || !o.extensions[this.name])
                    return Promise.resolve();
                const c = []
                  , l = o.extensions[this.name];
                t.thickness = void 0 !== l.thicknessFactor ? l.thicknessFactor : 0,
                void 0 !== l.thicknessTexture && c.push(n.assignTexture(t, "thicknessMap", l.thicknessTexture)),
                t.attenuationDistance = l.attenuationDistance || 1 / 0;
                const h = l.attenuationColor || [1, 1, 1];
                return t.attenuationColor = new r.q(h[0],h[1],h[2]),
                Promise.all(c)
            }
        }
        class v {
            constructor(e) {
                this.parser = e,
                this.name = l.KHR_MATERIALS_IOR
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? r.pb : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser.json.materials[e];
                if (!n.extensions || !n.extensions[this.name])
                    return Promise.resolve();
                const r = n.extensions[this.name];
                return t.ior = void 0 !== r.ior ? r.ior : 1.5,
                Promise.resolve()
            }
        }
        class _ {
            constructor(e) {
                this.parser = e,
                this.name = l.KHR_MATERIALS_SPECULAR
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? r.pb : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser
                  , o = n.json.materials[e];
                if (!o.extensions || !o.extensions[this.name])
                    return Promise.resolve();
                const c = []
                  , l = o.extensions[this.name];
                t.specularIntensity = void 0 !== l.specularFactor ? l.specularFactor : 1,
                void 0 !== l.specularTexture && c.push(n.assignTexture(t, "specularIntensityMap", l.specularTexture));
                const h = l.specularColorFactor || [1, 1, 1];
                return t.specularColor = new r.q(h[0],h[1],h[2]),
                void 0 !== l.specularColorTexture && c.push(n.assignTexture(t, "specularColorMap", l.specularColorTexture, r.mc)),
                Promise.all(c)
            }
        }
        class E {
            constructor(e) {
                this.parser = e,
                this.name = l.KHR_TEXTURE_BASISU
            }
            loadTexture(e) {
                const t = this.parser
                  , n = t.json
                  , r = n.textures[e];
                if (!r.extensions || !r.extensions[this.name])
                    return null;
                const o = r.extensions[this.name]
                  , c = t.options.ktx2Loader;
                if (!c) {
                    if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
                        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                    return null
                }
                return t.loadTextureImage(e, o.source, c)
            }
        }
        class M {
            constructor(e) {
                this.parser = e,
                this.name = l.EXT_TEXTURE_WEBP,
                this.isSupported = null
            }
            loadTexture(e) {
                const t = this.name
                  , n = this.parser
                  , r = n.json
                  , o = r.textures[e];
                if (!o.extensions || !o.extensions[t])
                    return null;
                const c = o.extensions[t]
                  , source = r.images[c.source];
                let l = n.textureLoader;
                if (source.uri) {
                    const e = n.options.manager.getHandler(source.uri);
                    null !== e && (l = e)
                }
                return this.detectSupport().then((function(o) {
                    if (o)
                        return n.loadTextureImage(e, c.source, l);
                    if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0)
                        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                    return n.loadTexture(e)
                }
                ))
            }
            detectSupport() {
                return this.isSupported || (this.isSupported = new Promise((function(e) {
                    const image = new Image;
                    image.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",
                    image.onload = image.onerror = function() {
                        e(1 === image.height)
                    }
                }
                ))),
                this.isSupported
            }
        }
        class S {
            constructor(e) {
                this.name = l.EXT_MESHOPT_COMPRESSION,
                this.parser = e
            }
            loadBufferView(e) {
                const t = this.parser.json
                  , n = t.bufferViews[e];
                if (n.extensions && n.extensions[this.name]) {
                    const e = n.extensions[this.name]
                      , r = this.parser.getDependency("buffer", e.buffer)
                      , o = this.parser.options.meshoptDecoder;
                    if (!o || !o.supported) {
                        if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
                            throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                        return null
                    }
                    return r.then((function(t) {
                        const n = e.byteOffset || 0
                          , r = e.byteLength || 0
                          , c = e.count
                          , l = e.byteStride
                          , source = new Uint8Array(t,n,r);
                        return o.decodeGltfBufferAsync ? o.decodeGltfBufferAsync(c, l, source, e.mode, e.filter).then((function(e) {
                            return e.buffer
                        }
                        )) : o.ready.then((function() {
                            const t = new ArrayBuffer(c * l);
                            return o.decodeGltfBuffer(new Uint8Array(t), c, l, source, e.mode, e.filter),
                            t
                        }
                        ))
                    }
                    ))
                }
                return null
            }
        }
        class y {
            constructor(e) {
                this.name = l.EXT_MESH_GPU_INSTANCING,
                this.parser = e
            }
            createNodeMesh(e) {
                const t = this.parser.json
                  , n = t.nodes[e];
                if (!n.extensions || !n.extensions[this.name] || void 0 === n.mesh)
                    return null;
                const o = t.meshes[n.mesh];
                for (const e of o.primitives)
                    if (e.mode !== D.TRIANGLES && e.mode !== D.TRIANGLE_STRIP && e.mode !== D.TRIANGLE_FAN && void 0 !== e.mode)
                        return null;
                const c = n.extensions[this.name].attributes
                  , l = []
                  , h = {};
                for (const e in c)
                    l.push(this.parser.getDependency("accessor", c[e]).then((t => (h[e] = t,
                    h[e]))));
                return l.length < 1 ? null : (l.push(this.parser.createNodeMesh(e)),
                Promise.all(l).then((e => {
                    const t = e.pop()
                      , n = t.isGroup ? t.children : [t]
                      , o = e[0].count
                      , c = [];
                    for (const e of n) {
                        const t = new r.jb
                          , p = new r.fc
                          , q = new r.Ib
                          , s = new r.fc(1,1,1)
                          , n = new r.M(e.geometry,e.material,o);
                        for (let i = 0; i < o; i++)
                            h.TRANSLATION && p.fromBufferAttribute(h.TRANSLATION, i),
                            h.ROTATION && q.fromBufferAttribute(h.ROTATION, i),
                            h.SCALE && s.fromBufferAttribute(h.SCALE, i),
                            n.setMatrixAt(i, t.compose(p, q, s));
                        for (const t in h)
                            "TRANSLATION" !== t && "ROTATION" !== t && "SCALE" !== t && e.geometry.setAttribute(t, h[t]);
                        r.yb.prototype.copy.call(n, e),
                        n.frustumCulled = !1,
                        this.parser.assignFinalMaterial(n),
                        c.push(n)
                    }
                    return t.isGroup ? (t.clear(),
                    t.add(...c),
                    t) : c[0]
                }
                )))
            }
        }
        const w = "glTF"
          , L = 1313821514
          , I = 5130562;
        class N {
            constructor(data) {
                this.name = l.KHR_BINARY_GLTF,
                this.content = null,
                this.body = null;
                const e = new DataView(data,0,12);
                if (this.header = {
                    magic: r.db.decodeText(new Uint8Array(data.slice(0, 4))),
                    version: e.getUint32(4, !0),
                    length: e.getUint32(8, !0)
                },
                this.header.magic !== w)
                    throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                if (this.header.version < 2)
                    throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
                const t = this.header.length - 12
                  , n = new DataView(data,12);
                let o = 0;
                for (; o < t; ) {
                    const e = n.getUint32(o, !0);
                    o += 4;
                    const t = n.getUint32(o, !0);
                    if (o += 4,
                    t === L) {
                        const t = new Uint8Array(data,12 + o,e);
                        this.content = r.db.decodeText(t)
                    } else if (t === I) {
                        const t = 12 + o;
                        this.body = data.slice(t, t + e)
                    }
                    o += e
                }
                if (null === this.content)
                    throw new Error("THREE.GLTFLoader: JSON content not found.")
            }
        }
        class P {
            constructor(e, t) {
                if (!t)
                    throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
                this.name = l.KHR_DRACO_MESH_COMPRESSION,
                this.json = e,
                this.dracoLoader = t,
                this.dracoLoader.preload()
            }
            decodePrimitive(e, t) {
                const n = this.json
                  , r = this.dracoLoader
                  , o = e.extensions[this.name].bufferView
                  , c = e.extensions[this.name].attributes
                  , l = {}
                  , h = {}
                  , d = {};
                for (const e in c) {
                    const t = X[e] || e.toLowerCase();
                    l[t] = c[e]
                }
                for (const t in e.attributes) {
                    const r = X[t] || t.toLowerCase();
                    if (void 0 !== c[t]) {
                        const o = n.accessors[e.attributes[t]]
                          , c = K[o.componentType];
                        d[r] = c.name,
                        h[r] = !0 === o.normalized
                    }
                }
                return t.getDependency("bufferView", o).then((function(e) {
                    return new Promise((function(t) {
                        r.decodeDracoFile(e, (function(e) {
                            for (const t in e.attributes) {
                                const n = e.attributes[t]
                                  , r = h[t];
                                void 0 !== r && (n.normalized = r)
                            }
                            t(e)
                        }
                        ), l, d)
                    }
                    ))
                }
                ))
            }
        }
        class O {
            constructor() {
                this.name = l.KHR_TEXTURE_TRANSFORM
            }
            extendTexture(e, t) {
                return void 0 !== t.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'),
                void 0 === t.offset && void 0 === t.rotation && void 0 === t.scale || (e = e.clone(),
                void 0 !== t.offset && e.offset.fromArray(t.offset),
                void 0 !== t.rotation && (e.rotation = t.rotation),
                void 0 !== t.scale && e.repeat.fromArray(t.scale),
                e.needsUpdate = !0),
                e
            }
        }
        class C extends r.qb {
            constructor(e) {
                super(),
                this.isGLTFSpecularGlossinessMaterial = !0;
                const t = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n")
                  , n = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n")
                  , o = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n")
                  , c = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n")
                  , l = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n")
                  , h = {
                    specular: {
                        value: (new r.q).setHex(16777215)
                    },
                    glossiness: {
                        value: 1
                    },
                    specularMap: {
                        value: null
                    },
                    glossinessMap: {
                        value: null
                    }
                };
                this._extraUniforms = h,
                this.onBeforeCompile = function(e) {
                    for (const t in h)
                        e.uniforms[t] = h[t];
                    e.fragmentShader = e.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", t).replace("#include <metalnessmap_pars_fragment>", n).replace("#include <roughnessmap_fragment>", o).replace("#include <metalnessmap_fragment>", c).replace("#include <lights_physical_fragment>", l)
                }
                ,
                Object.defineProperties(this, {
                    specular: {
                        get: function() {
                            return h.specular.value
                        },
                        set: function(e) {
                            h.specular.value = e
                        }
                    },
                    specularMap: {
                        get: function() {
                            return h.specularMap.value
                        },
                        set: function(e) {
                            h.specularMap.value = e,
                            e ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP
                        }
                    },
                    glossiness: {
                        get: function() {
                            return h.glossiness.value
                        },
                        set: function(e) {
                            h.glossiness.value = e
                        }
                    },
                    glossinessMap: {
                        get: function() {
                            return h.glossinessMap.value
                        },
                        set: function(e) {
                            h.glossinessMap.value = e,
                            e ? (this.defines.USE_GLOSSINESSMAP = "",
                            this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP,
                            delete this.defines.USE_UV)
                        }
                    }
                }),
                delete this.metalness,
                delete this.roughness,
                delete this.metalnessMap,
                delete this.roughnessMap,
                this.setValues(e)
            }
            copy(source) {
                return super.copy(source),
                this.specularMap = source.specularMap,
                this.specular.copy(source.specular),
                this.glossinessMap = source.glossinessMap,
                this.glossiness = source.glossiness,
                delete this.metalness,
                delete this.roughness,
                delete this.metalnessMap,
                delete this.roughnessMap,
                this
            }
        }
        class H {
            constructor() {
                this.name = l.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
                this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity"]
            }
            getMaterialType() {
                return C
            }
            extendParams(e, t, n) {
                const o = t.extensions[this.name];
                e.color = new r.q(1,1,1),
                e.opacity = 1;
                const c = [];
                if (Array.isArray(o.diffuseFactor)) {
                    const t = o.diffuseFactor;
                    e.color.fromArray(t),
                    e.opacity = t[3]
                }
                if (void 0 !== o.diffuseTexture && c.push(n.assignTexture(e, "map", o.diffuseTexture, r.mc)),
                e.emissive = new r.q(0,0,0),
                e.glossiness = void 0 !== o.glossinessFactor ? o.glossinessFactor : 1,
                e.specular = new r.q(1,1,1),
                Array.isArray(o.specularFactor) && e.specular.fromArray(o.specularFactor),
                void 0 !== o.specularGlossinessTexture) {
                    const t = o.specularGlossinessTexture;
                    c.push(n.assignTexture(e, "glossinessMap", t)),
                    c.push(n.assignTexture(e, "specularMap", t, r.mc))
                }
                return Promise.all(c)
            }
            createMaterial(e) {
                const t = new C(e);
                return t.fog = !0,
                t.color = e.color,
                t.map = void 0 === e.map ? null : e.map,
                t.lightMap = null,
                t.lightMapIntensity = 1,
                t.aoMap = void 0 === e.aoMap ? null : e.aoMap,
                t.aoMapIntensity = 1,
                t.emissive = e.emissive,
                t.emissiveIntensity = void 0 === e.emissiveIntensity ? 1 : e.emissiveIntensity,
                t.emissiveMap = void 0 === e.emissiveMap ? null : e.emissiveMap,
                t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap,
                t.bumpScale = 1,
                t.normalMap = void 0 === e.normalMap ? null : e.normalMap,
                t.normalMapType = r.Wb,
                e.normalScale && (t.normalScale = e.normalScale),
                t.displacementMap = null,
                t.displacementScale = 1,
                t.displacementBias = 0,
                t.specularMap = void 0 === e.specularMap ? null : e.specularMap,
                t.specular = e.specular,
                t.glossinessMap = void 0 === e.glossinessMap ? null : e.glossinessMap,
                t.glossiness = e.glossiness,
                t.alphaMap = null,
                t.envMap = void 0 === e.envMap ? null : e.envMap,
                t.envMapIntensity = 1,
                t
            }
        }
        class F {
            constructor() {
                this.name = l.KHR_MESH_QUANTIZATION
            }
        }
        class U extends r.P {
            constructor(e, t, n, r) {
                super(e, t, n, r)
            }
            copySampleValue_(e) {
                const t = this.resultBuffer
                  , n = this.sampleValues
                  , r = this.valueSize
                  , o = e * r * 3 + r;
                for (let i = 0; i !== r; i++)
                    t[i] = n[o + i];
                return t
            }
            interpolate_(e, t, n, r) {
                const o = this.resultBuffer
                  , c = this.sampleValues
                  , l = this.valueSize
                  , h = 2 * l
                  , d = 3 * l
                  , td = r - t
                  , p = (n - t) / td
                  , m = p * p
                  , f = m * p
                  , T = e * d
                  , x = T - d
                  , R = -2 * f + 3 * m
                  , A = f - m
                  , v = 1 - R
                  , _ = A - m + p;
                for (let i = 0; i !== l; i++) {
                    const e = c[x + i + l]
                      , t = c[x + i + h] * td
                      , n = c[T + i + l]
                      , r = c[T + i] * td;
                    o[i] = v * e + _ * t + R * n + A * r
                }
                return o
            }
        }
        const k = new r.Ib;
        class G extends U {
            interpolate_(e, t, n, r) {
                const o = super.interpolate_(e, t, n, r);
                return k.fromArray(o).normalize().toArray(o),
                o
            }
        }
        const D = {
            FLOAT: 5126,
            FLOAT_MAT3: 35675,
            FLOAT_MAT4: 35676,
            FLOAT_VEC2: 35664,
            FLOAT_VEC3: 35665,
            FLOAT_VEC4: 35666,
            LINEAR: 9729,
            REPEAT: 10497,
            SAMPLER_2D: 35678,
            POINTS: 0,
            LINES: 1,
            LINE_LOOP: 2,
            LINE_STRIP: 3,
            TRIANGLES: 4,
            TRIANGLE_STRIP: 5,
            TRIANGLE_FAN: 6,
            UNSIGNED_BYTE: 5121,
            UNSIGNED_SHORT: 5123
        }
          , K = {
            5120: Int8Array,
            5121: Uint8Array,
            5122: Int16Array,
            5123: Uint16Array,
            5125: Uint32Array,
            5126: Float32Array
        }
          , j = {
            9728: r.sb,
            9729: r.Y,
            9984: r.ub,
            9985: r.ab,
            9986: r.tb,
            9987: r.Z
        }
          , B = {
            33071: r.o,
            33648: r.rb,
            10497: r.Nb
        }
          , V = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 4,
            MAT3: 9,
            MAT4: 16
        }
          , X = {
            POSITION: "position",
            NORMAL: "normal",
            TANGENT: "tangent",
            TEXCOORD_0: "uv",
            TEXCOORD_1: "uv2",
            COLOR_0: "color",
            WEIGHTS_0: "skinWeight",
            JOINTS_0: "skinIndex"
        }
          , z = {
            scale: "scale",
            translation: "position",
            rotation: "quaternion",
            weights: "morphTargetInfluences"
        }
          , W = {
            CUBICSPLINE: void 0,
            LINEAR: r.R,
            STEP: r.Q
        }
          , Y = "OPAQUE"
          , J = "MASK"
          , Q = "BLEND";
        function Z(e, object, t) {
            for (const n in t.extensions)
                void 0 === e[n] && (object.userData.gltfExtensions = object.userData.gltfExtensions || {},
                object.userData.gltfExtensions[n] = t.extensions[n])
        }
        function $(object, e) {
            void 0 !== e.extras && ("object" == typeof e.extras ? Object.assign(object.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras))
        }
        function ee(e, t) {
            if (e.updateMorphTargets(),
            void 0 !== t.weights)
                for (let i = 0, n = t.weights.length; i < n; i++)
                    e.morphTargetInfluences[i] = t.weights[i];
            if (t.extras && Array.isArray(t.extras.targetNames)) {
                const n = t.extras.targetNames;
                if (e.morphTargetInfluences.length === n.length) {
                    e.morphTargetDictionary = {};
                    for (let i = 0, t = n.length; i < t; i++)
                        e.morphTargetDictionary[n[i]] = i
                } else
                    console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
            }
        }
        function te(e) {
            const t = e.extensions && e.extensions[l.KHR_DRACO_MESH_COMPRESSION];
            let n;
            return n = t ? "draco:" + t.bufferView + ":" + t.indices + ":" + se(t.attributes) : e.indices + ":" + se(e.attributes) + ":" + e.mode,
            n
        }
        function se(e) {
            let t = "";
            const n = Object.keys(e).sort();
            for (let i = 0, r = n.length; i < r; i++)
                t += n[i] + ":" + e[n[i]] + ";";
            return t
        }
        function ne(e) {
            switch (e) {
            case Int8Array:
                return 1 / 127;
            case Uint8Array:
                return 1 / 255;
            case Int16Array:
                return 1 / 32767;
            case Uint16Array:
                return 1 / 65535;
            default:
                throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
            }
        }
        class re {
            constructor(e={}, t={}) {
                this.json = e,
                this.extensions = {},
                this.plugins = {},
                this.options = t,
                this.cache = new c,
                this.associations = new Map,
                this.primitiveCache = {},
                this.meshCache = {
                    refs: {},
                    uses: {}
                },
                this.cameraCache = {
                    refs: {},
                    uses: {}
                },
                this.lightCache = {
                    refs: {},
                    uses: {}
                },
                this.sourceCache = {},
                this.textureCache = {},
                this.nodeNamesUsed = {};
                const n = !0 === /^((?!chrome|android).)*safari/i.test(navigator.userAgent)
                  , o = navigator.userAgent.indexOf("Firefox") > -1
                  , l = o ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1;
                "undefined" == typeof createImageBitmap || n || o && l < 98 ? this.textureLoader = new r.Yb(this.options.manager) : this.textureLoader = new r.L(this.options.manager),
                this.textureLoader.setCrossOrigin(this.options.crossOrigin),
                this.textureLoader.setRequestHeader(this.options.requestHeader),
                this.fileLoader = new r.F(this.options.manager),
                this.fileLoader.setResponseType("arraybuffer"),
                "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
            }
            setExtensions(e) {
                this.extensions = e
            }
            setPlugins(e) {
                this.plugins = e
            }
            parse(e, t) {
                const n = this
                  , r = this.json
                  , o = this.extensions;
                this.cache.removeAll(),
                this._invokeAll((function(e) {
                    return e._markDefs && e._markDefs()
                }
                )),
                Promise.all(this._invokeAll((function(e) {
                    return e.beforeRoot && e.beforeRoot()
                }
                ))).then((function() {
                    return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
                }
                )).then((function(t) {
                    const c = {
                        scene: t[0][r.scene || 0],
                        scenes: t[0],
                        animations: t[1],
                        cameras: t[2],
                        asset: r.asset,
                        parser: n,
                        userData: {}
                    };
                    Z(o, c, r),
                    $(c, r),
                    Promise.all(n._invokeAll((function(e) {
                        return e.afterRoot && e.afterRoot(c)
                    }
                    ))).then((function() {
                        e(c)
                    }
                    ))
                }
                )).catch(t)
            }
            _markDefs() {
                const e = this.json.nodes || []
                  , t = this.json.skins || []
                  , n = this.json.meshes || [];
                for (let n = 0, r = t.length; n < r; n++) {
                    const r = t[n].joints;
                    for (let i = 0, t = r.length; i < t; i++)
                        e[r[i]].isBone = !0
                }
                for (let t = 0, r = e.length; t < r; t++) {
                    const r = e[t];
                    void 0 !== r.mesh && (this._addNodeRef(this.meshCache, r.mesh),
                    void 0 !== r.skin && (n[r.mesh].isSkinnedMesh = !0)),
                    void 0 !== r.camera && this._addNodeRef(this.cameraCache, r.camera)
                }
            }
            _addNodeRef(e, t) {
                void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0),
                e.refs[t]++)
            }
            _getNodeRef(e, t, object) {
                if (e.refs[t] <= 1)
                    return object;
                const n = object.clone()
                  , r = (e, t) => {
                    const n = this.associations.get(e);
                    null != n && this.associations.set(t, n);
                    for (const [i,n] of e.children.entries())
                        r(n, t.children[i])
                }
                ;
                return r(object, n),
                n.name += "_instance_" + e.uses[t]++,
                n
            }
            _invokeOne(e) {
                const t = Object.values(this.plugins);
                t.push(this);
                for (let i = 0; i < t.length; i++) {
                    const n = e(t[i]);
                    if (n)
                        return n
                }
                return null
            }
            _invokeAll(e) {
                const t = Object.values(this.plugins);
                t.unshift(this);
                const n = [];
                for (let i = 0; i < t.length; i++) {
                    const r = e(t[i]);
                    r && n.push(r)
                }
                return n
            }
            getDependency(e, t) {
                const n = e + ":" + t;
                let r = this.cache.get(n);
                if (!r) {
                    switch (e) {
                    case "scene":
                        r = this.loadScene(t);
                        break;
                    case "node":
                        r = this.loadNode(t);
                        break;
                    case "mesh":
                        r = this._invokeOne((function(e) {
                            return e.loadMesh && e.loadMesh(t)
                        }
                        ));
                        break;
                    case "accessor":
                        r = this.loadAccessor(t);
                        break;
                    case "bufferView":
                        r = this._invokeOne((function(e) {
                            return e.loadBufferView && e.loadBufferView(t)
                        }
                        ));
                        break;
                    case "buffer":
                        r = this.loadBuffer(t);
                        break;
                    case "material":
                        r = this._invokeOne((function(e) {
                            return e.loadMaterial && e.loadMaterial(t)
                        }
                        ));
                        break;
                    case "texture":
                        r = this._invokeOne((function(e) {
                            return e.loadTexture && e.loadTexture(t)
                        }
                        ));
                        break;
                    case "skin":
                        r = this.loadSkin(t);
                        break;
                    case "animation":
                        r = this._invokeOne((function(e) {
                            return e.loadAnimation && e.loadAnimation(t)
                        }
                        ));
                        break;
                    case "camera":
                        r = this.loadCamera(t);
                        break;
                    default:
                        throw new Error("Unknown type: " + e)
                    }
                    this.cache.add(n, r)
                }
                return r
            }
            getDependencies(e) {
                let t = this.cache.get(e);
                if (!t) {
                    const n = this
                      , defs = this.json[e + ("mesh" === e ? "es" : "s")] || [];
                    t = Promise.all(defs.map((function(t, r) {
                        return n.getDependency(e, r)
                    }
                    ))),
                    this.cache.add(e, t)
                }
                return t
            }
            loadBuffer(e) {
                const t = this.json.buffers[e]
                  , n = this.fileLoader;
                if (t.type && "arraybuffer" !== t.type)
                    throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
                if (void 0 === t.uri && 0 === e)
                    return Promise.resolve(this.extensions[l.KHR_BINARY_GLTF].body);
                const o = this.options;
                return new Promise((function(e, c) {
                    n.load(r.db.resolveURL(t.uri, o.path), e, void 0, (function() {
                        c(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
                    }
                    ))
                }
                ))
            }
            loadBufferView(e) {
                const t = this.json.bufferViews[e];
                return this.getDependency("buffer", t.buffer).then((function(e) {
                    const n = t.byteLength || 0
                      , r = t.byteOffset || 0;
                    return e.slice(r, r + n)
                }
                ))
            }
            loadAccessor(e) {
                const t = this
                  , n = this.json
                  , o = this.json.accessors[e];
                if (void 0 === o.bufferView && void 0 === o.sparse)
                    return Promise.resolve(null);
                const c = [];
                return void 0 !== o.bufferView ? c.push(this.getDependency("bufferView", o.bufferView)) : c.push(null),
                void 0 !== o.sparse && (c.push(this.getDependency("bufferView", o.sparse.indices.bufferView)),
                c.push(this.getDependency("bufferView", o.sparse.values.bufferView))),
                Promise.all(c).then((function(e) {
                    const c = e[0]
                      , l = V[o.type]
                      , h = K[o.componentType]
                      , d = h.BYTES_PER_ELEMENT
                      , m = d * l
                      , f = o.byteOffset || 0
                      , T = void 0 !== o.bufferView ? n.bufferViews[o.bufferView].byteStride : void 0
                      , x = !0 === o.normalized;
                    let R, A;
                    if (T && T !== m) {
                        const e = Math.floor(f / T)
                          , n = "InterleavedBuffer:" + o.bufferView + ":" + o.componentType + ":" + e + ":" + o.count;
                        let m = t.cache.get(n);
                        m || (R = new h(c,e * T,o.count * T / d),
                        m = new r.N(R,T / d),
                        t.cache.add(n, m)),
                        A = new r.O(m,l,f % T / d,x)
                    } else
                        R = null === c ? new h(o.count * l) : new h(c,f,o.count * l),
                        A = new r.k(R,l,x);
                    if (void 0 !== o.sparse) {
                        const t = V.SCALAR
                          , n = K[o.sparse.indices.componentType]
                          , d = o.sparse.indices.byteOffset || 0
                          , m = o.sparse.values.byteOffset || 0
                          , f = new n(e[1],d,o.sparse.count * t)
                          , T = new h(e[2],m,o.sparse.count * l);
                        null !== c && (A = new r.k(A.array.slice(),A.itemSize,A.normalized));
                        for (let i = 0, e = f.length; i < e; i++) {
                            const e = f[i];
                            if (A.setX(e, T[i * l]),
                            l >= 2 && A.setY(e, T[i * l + 1]),
                            l >= 3 && A.setZ(e, T[i * l + 2]),
                            l >= 4 && A.setW(e, T[i * l + 3]),
                            l >= 5)
                                throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                        }
                    }
                    return A
                }
                ))
            }
            loadTexture(e) {
                const t = this.json
                  , n = this.options
                  , r = t.textures[e].source
                  , o = t.images[r];
                let c = this.textureLoader;
                if (o.uri) {
                    const e = n.manager.getHandler(o.uri);
                    null !== e && (c = e)
                }
                return this.loadTextureImage(e, r, c)
            }
            loadTextureImage(e, t, n) {
                const o = this
                  , c = this.json
                  , l = c.textures[e]
                  , h = c.images[t]
                  , d = (h.uri || h.bufferView) + ":" + l.sampler;
                if (this.textureCache[d])
                    return this.textureCache[d];
                const m = this.loadImageSource(t, n).then((function(t) {
                    t.flipY = !1,
                    t.name = l.name || h.name || "";
                    const n = (c.samplers || {})[l.sampler] || {};
                    return t.magFilter = j[n.magFilter] || r.Y,
                    t.minFilter = j[n.minFilter] || r.Z,
                    t.wrapS = B[n.wrapS] || r.Nb,
                    t.wrapT = B[n.wrapT] || r.Nb,
                    o.associations.set(t, {
                        textures: e
                    }),
                    t
                }
                )).catch((function() {
                    return null
                }
                ));
                return this.textureCache[d] = m,
                m
            }
            loadImageSource(e, t) {
                const n = this
                  , o = this.json
                  , c = this.options;
                if (void 0 !== this.sourceCache[e])
                    return this.sourceCache[e].then((e => e.clone()));
                const l = o.images[e]
                  , h = self.URL || self.webkitURL;
                let d = l.uri || ""
                  , m = !1;
                if (void 0 !== l.bufferView)
                    d = n.getDependency("bufferView", l.bufferView).then((function(e) {
                        m = !0;
                        const t = new Blob([e],{
                            type: l.mimeType
                        });
                        return d = h.createObjectURL(t),
                        d
                    }
                    ));
                else if (void 0 === l.uri)
                    throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
                const f = Promise.resolve(d).then((function(e) {
                    return new Promise((function(n, o) {
                        let l = n;
                        !0 === t.isImageBitmapLoader && (l = function(e) {
                            const t = new r.Xb(e);
                            t.needsUpdate = !0,
                            n(t)
                        }
                        ),
                        t.load(r.db.resolveURL(e, c.path), l, void 0, o)
                    }
                    ))
                }
                )).then((function(e) {
                    var t;
                    return !0 === m && h.revokeObjectURL(d),
                    e.userData.mimeType = l.mimeType || ((t = l.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/) ? "image/jpeg" : t.search(/\.webp($|\?)/i) > 0 || 0 === t.search(/^data\:image\/webp/) ? "image/webp" : "image/png"),
                    e
                }
                )).catch((function(e) {
                    throw console.error("THREE.GLTFLoader: Couldn't load texture", d),
                    e
                }
                ));
                return this.sourceCache[e] = f,
                f
            }
            assignTexture(e, t, n, r) {
                const o = this;
                return this.getDependency("texture", n.index).then((function(c) {
                    if (void 0 === n.texCoord || 0 == n.texCoord || "aoMap" === t && 1 == n.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + n.texCoord + " for texture " + t + " not yet supported."),
                    o.extensions[l.KHR_TEXTURE_TRANSFORM]) {
                        const e = void 0 !== n.extensions ? n.extensions[l.KHR_TEXTURE_TRANSFORM] : void 0;
                        if (e) {
                            const t = o.associations.get(c);
                            c = o.extensions[l.KHR_TEXTURE_TRANSFORM].extendTexture(c, e),
                            o.associations.set(c, t)
                        }
                    }
                    return void 0 !== r && (c.encoding = r),
                    e[t] = c,
                    c
                }
                ))
            }
            assignFinalMaterial(e) {
                const t = e.geometry;
                let n = e.material;
                const o = void 0 === t.attributes.tangent
                  , c = void 0 !== t.attributes.color
                  , l = void 0 === t.attributes.normal;
                if (e.isPoints) {
                    const e = "PointsMaterial:" + n.uuid;
                    let t = this.cache.get(e);
                    t || (t = new r.Gb,
                    r.gb.prototype.copy.call(t, n),
                    t.color.copy(n.color),
                    t.map = n.map,
                    t.sizeAttenuation = !1,
                    this.cache.add(e, t)),
                    n = t
                } else if (e.isLine) {
                    const e = "LineBasicMaterial:" + n.uuid;
                    let t = this.cache.get(e);
                    t || (t = new r.U,
                    r.gb.prototype.copy.call(t, n),
                    t.color.copy(n.color),
                    this.cache.add(e, t)),
                    n = t
                }
                if (o || c || l) {
                    let e = "ClonedMaterial:" + n.uuid + ":";
                    n.isGLTFSpecularGlossinessMaterial && (e += "specular-glossiness:"),
                    o && (e += "derivative-tangents:"),
                    c && (e += "vertex-colors:"),
                    l && (e += "flat-shading:");
                    let t = this.cache.get(e);
                    t || (t = n.clone(),
                    c && (t.vertexColors = !0),
                    l && (t.flatShading = !0),
                    o && (t.normalScale && (t.normalScale.y *= -1),
                    t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)),
                    this.cache.add(e, t),
                    this.associations.set(t, this.associations.get(n))),
                    n = t
                }
                n.aoMap && void 0 === t.attributes.uv2 && void 0 !== t.attributes.uv && t.setAttribute("uv2", t.attributes.uv),
                e.material = n
            }
            getMaterialType() {
                return r.qb
            }
            loadMaterial(e) {
                const t = this
                  , n = this.json
                  , o = this.extensions
                  , c = n.materials[e];
                let h;
                const d = {}
                  , m = c.extensions || {}
                  , f = [];
                if (m[l.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
                    const e = o[l.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
                    h = e.getMaterialType(),
                    f.push(e.extendParams(d, c, t))
                } else if (m[l.KHR_MATERIALS_UNLIT]) {
                    const e = o[l.KHR_MATERIALS_UNLIT];
                    h = e.getMaterialType(),
                    f.push(e.extendParams(d, c, t))
                } else {
                    const n = c.pbrMetallicRoughness || {};
                    if (d.color = new r.q(1,1,1),
                    d.opacity = 1,
                    Array.isArray(n.baseColorFactor)) {
                        const e = n.baseColorFactor;
                        d.color.fromArray(e),
                        d.opacity = e[3]
                    }
                    void 0 !== n.baseColorTexture && f.push(t.assignTexture(d, "map", n.baseColorTexture, r.mc)),
                    d.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1,
                    d.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1,
                    void 0 !== n.metallicRoughnessTexture && (f.push(t.assignTexture(d, "metalnessMap", n.metallicRoughnessTexture)),
                    f.push(t.assignTexture(d, "roughnessMap", n.metallicRoughnessTexture))),
                    h = this._invokeOne((function(t) {
                        return t.getMaterialType && t.getMaterialType(e)
                    }
                    )),
                    f.push(Promise.all(this._invokeAll((function(t) {
                        return t.extendMaterialParams && t.extendMaterialParams(e, d)
                    }
                    ))))
                }
                !0 === c.doubleSided && (d.side = r.z);
                const T = c.alphaMode || Y;
                if (T === Q ? (d.transparent = !0,
                d.depthWrite = !1) : (d.transparent = !1,
                T === J && (d.alphaTest = void 0 !== c.alphaCutoff ? c.alphaCutoff : .5)),
                void 0 !== c.normalTexture && h !== r.lb && (f.push(t.assignTexture(d, "normalMap", c.normalTexture)),
                d.normalScale = new r.ec(1,1),
                void 0 !== c.normalTexture.scale)) {
                    const e = c.normalTexture.scale;
                    d.normalScale.set(e, e)
                }
                return void 0 !== c.occlusionTexture && h !== r.lb && (f.push(t.assignTexture(d, "aoMap", c.occlusionTexture)),
                void 0 !== c.occlusionTexture.strength && (d.aoMapIntensity = c.occlusionTexture.strength)),
                void 0 !== c.emissiveFactor && h !== r.lb && (d.emissive = (new r.q).fromArray(c.emissiveFactor)),
                void 0 !== c.emissiveTexture && h !== r.lb && f.push(t.assignTexture(d, "emissiveMap", c.emissiveTexture, r.mc)),
                Promise.all(f).then((function() {
                    let n;
                    return n = h === C ? o[l.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(d) : new h(d),
                    c.name && (n.name = c.name),
                    $(n, c),
                    t.associations.set(n, {
                        materials: e
                    }),
                    c.extensions && Z(o, n, c),
                    n
                }
                ))
            }
            createUniqueName(e) {
                const t = r.Hb.sanitizeNodeName(e || "");
                let n = t;
                for (let i = 1; this.nodeNamesUsed[n]; ++i)
                    n = t + "_" + i;
                return this.nodeNamesUsed[n] = !0,
                n
            }
            loadGeometries(e) {
                const t = this
                  , n = this.extensions
                  , o = this.primitiveCache;
                function c(e) {
                    return n[l.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then((function(n) {
                        return ie(n, e, t)
                    }
                    ))
                }
                const h = [];
                for (let i = 0, n = e.length; i < n; i++) {
                    const n = e[i]
                      , d = te(n)
                      , m = o[d];
                    if (m)
                        h.push(m.promise);
                    else {
                        let e;
                        e = n.extensions && n.extensions[l.KHR_DRACO_MESH_COMPRESSION] ? c(n) : ie(new r.l, n, t),
                        o[d] = {
                            primitive: n,
                            promise: e
                        },
                        h.push(e)
                    }
                }
                return Promise.all(h)
            }
            loadMesh(e) {
                const t = this
                  , n = this.json
                  , o = this.extensions
                  , c = n.meshes[e]
                  , l = c.primitives
                  , h = [];
                for (let i = 0, e = l.length; i < e; i++) {
                    const e = void 0 === l[i].material ? (void 0 === (d = this.cache).DefaultMaterial && (d.DefaultMaterial = new r.qb({
                        color: 16777215,
                        emissive: 0,
                        metalness: 1,
                        roughness: 1,
                        transparent: !1,
                        depthTest: !0,
                        side: r.I
                    })),
                    d.DefaultMaterial) : this.getDependency("material", l[i].material);
                    h.push(e)
                }
                var d;
                return h.push(t.loadGeometries(l)),
                Promise.all(h).then((function(n) {
                    const h = n.slice(0, n.length - 1)
                      , d = n[n.length - 1]
                      , m = [];
                    for (let i = 0, n = d.length; i < n; i++) {
                        const n = d[i]
                          , f = l[i];
                        let T;
                        const x = h[i];
                        if (f.mode === D.TRIANGLES || f.mode === D.TRIANGLE_STRIP || f.mode === D.TRIANGLE_FAN || void 0 === f.mode)
                            T = !0 === c.isSkinnedMesh ? new r.Rb(n,x) : new r.kb(n,x),
                            !0 !== T.isSkinnedMesh || T.geometry.attributes.skinWeight.normalized || T.normalizeSkinWeights(),
                            f.mode === D.TRIANGLE_STRIP ? T.geometry = ae(T.geometry, r.ac) : f.mode === D.TRIANGLE_FAN && (T.geometry = ae(T.geometry, r.Zb));
                        else if (f.mode === D.LINES)
                            T = new r.W(n,x);
                        else if (f.mode === D.LINE_STRIP)
                            T = new r.T(n,x);
                        else if (f.mode === D.LINE_LOOP)
                            T = new r.V(n,x);
                        else {
                            if (f.mode !== D.POINTS)
                                throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + f.mode);
                            T = new r.Fb(n,x)
                        }
                        Object.keys(T.geometry.morphAttributes).length > 0 && ee(T, c),
                        T.name = t.createUniqueName(c.name || "mesh_" + e),
                        $(T, c),
                        f.extensions && Z(o, T, f),
                        t.assignFinalMaterial(T),
                        m.push(T)
                    }
                    for (let i = 0, n = m.length; i < n; i++)
                        t.associations.set(m[i], {
                            meshes: e,
                            primitives: i
                        });
                    if (1 === m.length)
                        return m[0];
                    const f = new r.K;
                    t.associations.set(f, {
                        meshes: e
                    });
                    for (let i = 0, e = m.length; i < e; i++)
                        f.add(m[i]);
                    return f
                }
                ))
            }
            loadCamera(e) {
                let t;
                const n = this.json.cameras[e]
                  , o = n[n.type];
                if (o)
                    return "perspective" === n.type ? t = new r.Cb(r.hb.radToDeg(o.yfov),o.aspectRatio || 1,o.znear || 1,o.zfar || 2e6) : "orthographic" === n.type && (t = new r.zb(-o.xmag,o.xmag,o.ymag,-o.ymag,o.znear,o.zfar)),
                    n.name && (t.name = this.createUniqueName(n.name)),
                    $(t, n),
                    Promise.resolve(t);
                console.warn("THREE.GLTFLoader: Missing camera parameters.")
            }
            loadSkin(e) {
                const t = this.json.skins[e]
                  , n = {
                    joints: t.joints
                };
                return void 0 === t.inverseBindMatrices ? Promise.resolve(n) : this.getDependency("accessor", t.inverseBindMatrices).then((function(e) {
                    return n.inverseBindMatrices = e,
                    n
                }
                ))
            }
            loadAnimation(e) {
                const t = this.json.animations[e]
                  , n = []
                  , o = []
                  , c = []
                  , l = []
                  , h = [];
                for (let i = 0, e = t.channels.length; i < e; i++) {
                    const e = t.channels[i]
                      , r = t.samplers[e.sampler]
                      , d = e.target
                      , m = d.node
                      , input = void 0 !== t.parameters ? t.parameters[r.input] : r.input
                      , output = void 0 !== t.parameters ? t.parameters[r.output] : r.output;
                    n.push(this.getDependency("node", m)),
                    o.push(this.getDependency("accessor", input)),
                    c.push(this.getDependency("accessor", output)),
                    l.push(r),
                    h.push(d)
                }
                return Promise.all([Promise.all(n), Promise.all(o), Promise.all(c), Promise.all(l), Promise.all(h)]).then((function(n) {
                    const o = n[0]
                      , c = n[1]
                      , l = n[2]
                      , h = n[3]
                      , d = n[4]
                      , m = [];
                    for (let i = 0, e = o.length; i < e; i++) {
                        const e = o[i]
                          , t = c[i]
                          , n = l[i]
                          , f = h[i]
                          , T = d[i];
                        if (void 0 === e)
                            continue;
                        let x;
                        switch (e.updateMatrix(),
                        z[T.path]) {
                        case z.weights:
                            x = r.xb;
                            break;
                        case z.rotation:
                            x = r.Jb;
                            break;
                        default:
                            x = r.hc
                        }
                        const R = e.name ? e.name : e.uuid
                          , A = void 0 !== f.interpolation ? W[f.interpolation] : r.R
                          , v = [];
                        z[T.path] === z.weights ? e.traverse((function(object) {
                            object.morphTargetInfluences && v.push(object.name ? object.name : object.uuid)
                        }
                        )) : v.push(R);
                        let _ = n.array;
                        if (n.normalized) {
                            const e = ne(_.constructor)
                              , t = new Float32Array(_.length);
                            for (let n = 0, r = _.length; n < r; n++)
                                t[n] = _[n] * e;
                            _ = t
                        }
                        for (let e = 0, n = v.length; e < n; e++) {
                            const track = new x(v[e] + "." + z[T.path],t.array,_,A);
                            "CUBICSPLINE" === f.interpolation && (track.createInterpolant = function(e) {
                                return new (this instanceof r.Jb ? G : U)(this.times,this.values,this.getValueSize() / 3,e)
                            }
                            ,
                            track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0),
                            m.push(track)
                        }
                    }
                    const f = t.name ? t.name : "animation_" + e;
                    return new r.e(f,void 0,m)
                }
                ))
            }
            createNodeMesh(e) {
                const t = this.json
                  , n = this
                  , r = t.nodes[e];
                return void 0 === r.mesh ? null : n.getDependency("mesh", r.mesh).then((function(e) {
                    const t = n._getNodeRef(n.meshCache, r.mesh, e);
                    return void 0 !== r.weights && t.traverse((function(e) {
                        if (e.isMesh)
                            for (let i = 0, t = r.weights.length; i < t; i++)
                                e.morphTargetInfluences[i] = r.weights[i]
                    }
                    )),
                    t
                }
                ))
            }
            loadNode(e) {
                const t = this.json
                  , n = this.extensions
                  , o = this
                  , c = t.nodes[e]
                  , l = c.name ? o.createUniqueName(c.name) : "";
                return function() {
                    const t = []
                      , n = o._invokeOne((function(t) {
                        return t.createNodeMesh && t.createNodeMesh(e)
                    }
                    ));
                    return n && t.push(n),
                    void 0 !== c.camera && t.push(o.getDependency("camera", c.camera).then((function(e) {
                        return o._getNodeRef(o.cameraCache, c.camera, e)
                    }
                    ))),
                    o._invokeAll((function(t) {
                        return t.createNodeAttachment && t.createNodeAttachment(e)
                    }
                    )).forEach((function(e) {
                        t.push(e)
                    }
                    )),
                    Promise.all(t)
                }().then((function(t) {
                    let h;
                    if (h = !0 === c.isBone ? new r.h : t.length > 1 ? new r.K : 1 === t.length ? t[0] : new r.yb,
                    h !== t[0])
                        for (let i = 0, e = t.length; i < e; i++)
                            h.add(t[i]);
                    if (c.name && (h.userData.name = c.name,
                    h.name = l),
                    $(h, c),
                    c.extensions && Z(n, h, c),
                    void 0 !== c.matrix) {
                        const e = new r.jb;
                        e.fromArray(c.matrix),
                        h.applyMatrix4(e)
                    } else
                        void 0 !== c.translation && h.position.fromArray(c.translation),
                        void 0 !== c.rotation && h.quaternion.fromArray(c.rotation),
                        void 0 !== c.scale && h.scale.fromArray(c.scale);
                    return o.associations.has(h) || o.associations.set(h, {}),
                    o.associations.get(h).nodes = e,
                    h
                }
                ))
            }
            loadScene(e) {
                const t = this.json
                  , n = this.extensions
                  , o = this.json.scenes[e]
                  , c = this
                  , l = new r.K;
                o.name && (l.name = c.createUniqueName(o.name)),
                $(l, o),
                o.extensions && Z(n, l, o);
                const h = o.nodes || []
                  , d = [];
                for (let i = 0, e = h.length; i < e; i++)
                    d.push(oe(h[i], l, t, c));
                return Promise.all(d).then((function() {
                    return c.associations = (e => {
                        const t = new Map;
                        for (const [e,n] of c.associations)
                            (e instanceof r.gb || e instanceof r.Xb) && t.set(e, n);
                        return e.traverse((e => {
                            const n = c.associations.get(e);
                            null != n && t.set(e, n)
                        }
                        )),
                        t
                    }
                    )(l),
                    l
                }
                ))
            }
        }
        function oe(e, t, n, o) {
            const c = n.nodes[e];
            return o.getDependency("node", e).then((function(e) {
                if (void 0 === c.skin)
                    return e;
                let t;
                return o.getDependency("skin", c.skin).then((function(e) {
                    t = e;
                    const n = [];
                    for (let i = 0, e = t.joints.length; i < e; i++)
                        n.push(o.getDependency("node", t.joints[i]));
                    return Promise.all(n)
                }
                )).then((function(n) {
                    return e.traverse((function(e) {
                        if (!e.isMesh)
                            return;
                        const o = []
                          , c = [];
                        for (let e = 0, l = n.length; e < l; e++) {
                            const l = n[e];
                            if (l) {
                                o.push(l);
                                const n = new r.jb;
                                void 0 !== t.inverseBindMatrices && n.fromArray(t.inverseBindMatrices.array, 16 * e),
                                c.push(n)
                            } else
                                console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[e])
                        }
                        e.bind(new r.Qb(o,c), e.matrixWorld)
                    }
                    )),
                    e
                }
                ))
            }
            )).then((function(e) {
                t.add(e);
                const r = [];
                if (c.children) {
                    const t = c.children;
                    for (let i = 0, c = t.length; i < c; i++) {
                        const c = t[i];
                        r.push(oe(c, e, n, o))
                    }
                }
                return Promise.all(r)
            }
            ))
        }
        function ie(e, t, n) {
            const o = t.attributes
              , c = [];
            function l(t, r) {
                return n.getDependency("accessor", t).then((function(t) {
                    e.setAttribute(r, t)
                }
                ))
            }
            for (const t in o) {
                const n = X[t] || t.toLowerCase();
                n in e.attributes || c.push(l(o[t], n))
            }
            if (void 0 !== t.indices && !e.index) {
                const r = n.getDependency("accessor", t.indices).then((function(t) {
                    e.setIndex(t)
                }
                ));
                c.push(r)
            }
            return $(e, t),
            function(e, t, n) {
                const o = t.attributes
                  , c = new r.i;
                if (void 0 === o.POSITION) 
                    return;
                {
                    const e = n.json.accessors[o.POSITION]
                      , t = e.min
                      , l = e.max;
                    if (void 0 === t || void 0 === l)
                        return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                    if (c.set(new r.fc(t[0],t[1],t[2]), new r.fc(l[0],l[1],l[2])),
                    e.normalized) {
                        const t = ne(K[e.componentType]);
                        c.min.multiplyScalar(t),
                        c.max.multiplyScalar(t)
                    }
                }
                const l = t.targets;
                if (void 0 !== l) {
                    const e = new r.fc
                      , t = new r.fc;
                    for (let i = 0, r = l.length; i < r; i++) {
                        const r = l[i];
                        if (void 0 !== r.POSITION) {
                            const o = n.json.accessors[r.POSITION]
                              , c = o.min
                              , l = o.max;
                            if (void 0 !== c && void 0 !== l) {
                                if (t.setX(Math.max(Math.abs(c[0]), Math.abs(l[0]))),
                                t.setY(Math.max(Math.abs(c[1]), Math.abs(l[1]))),
                                t.setZ(Math.max(Math.abs(c[2]), Math.abs(l[2]))),
                                o.normalized) {
                                    const e = ne(K[o.componentType]);
                                    t.multiplyScalar(e)
                                }
                                e.max(t)
                            } else
                                console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                        }
                    }
                    c.expandByVector(e)
                }
                e.boundingBox = c;
                const h = new r.Sb;
                c.getCenter(h.center),
                h.radius = c.min.distanceTo(c.max) / 2,
                e.boundingSphere = h
            }(e, t, n),
            Promise.all(c).then((function() {
                return void 0 !== t.targets ? function(e, t, n) {
                    let r = !1
                      , o = !1
                      , c = !1;
                    for (let i = 0, e = t.length; i < e; i++) {
                        const e = t[i];
                        if (void 0 !== e.POSITION && (r = !0),
                        void 0 !== e.NORMAL && (o = !0),
                        void 0 !== e.COLOR_0 && (c = !0),
                        r && o && c)
                            break
                    }
                    if (!r && !o && !c)
                        return Promise.resolve(e);
                    const l = []
                      , h = []
                      , d = [];
                    for (let i = 0, m = t.length; i < m; i++) {
                        const m = t[i];
                        if (r) {
                            const t = void 0 !== m.POSITION ? n.getDependency("accessor", m.POSITION) : e.attributes.position;
                            l.push(t)
                        }
                        if (o) {
                            const t = void 0 !== m.NORMAL ? n.getDependency("accessor", m.NORMAL) : e.attributes.normal;
                            h.push(t)
                        }
                        if (c) {
                            const t = void 0 !== m.COLOR_0 ? n.getDependency("accessor", m.COLOR_0) : e.attributes.color;
                            d.push(t)
                        }
                    }
                    return Promise.all([Promise.all(l), Promise.all(h), Promise.all(d)]).then((function(t) {
                        const n = t[0]
                          , l = t[1]
                          , h = t[2];
                        return r && (e.morphAttributes.position = n),
                        o && (e.morphAttributes.normal = l),
                        c && (e.morphAttributes.color = h),
                        e.morphTargetsRelative = !0,
                        e
                    }
                    ))
                }(e, t.targets, n) : e
            }
            ))
        }
        function ae(e, t) {
            let n = e.getIndex();
            if (null === n) {
                const t = []
                  , r = e.getAttribute("position");
                if (void 0 === r)
                    return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),
                    e;
                for (let i = 0; i < r.count; i++)
                    t.push(i);
                e.setIndex(t),
                n = e.getIndex()
            }
            const o = n.count - 2
              , c = [];
            if (t === r.Zb)
                for (let i = 1; i <= o; i++)
                    c.push(n.getX(0)),
                    c.push(n.getX(i)),
                    c.push(n.getX(i + 1));
            else
                for (let i = 0; i < o; i++)
                    i % 2 == 0 ? (c.push(n.getX(i)),
                    c.push(n.getX(i + 1)),
                    c.push(n.getX(i + 2))) : (c.push(n.getX(i + 2)),
                    c.push(n.getX(i + 1)),
                    c.push(n.getX(i)));
            c.length / 3 !== o && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
            const l = e.clone();
            return l.setIndex(c),
            l
        }
    }
}]);
</body>
</html>